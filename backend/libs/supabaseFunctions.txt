CREATE OR REPLACE FUNCTION match_embeddings(
    query_embedding VECTOR(768),
    match_threshold FLOAT,
    match_count INT,
    resource_ids UUID[]
)
RETURNS TABLE (
    id UUID,
    content TEXT,
    similarity FLOAT,
    resource_id UUID,
    resource_title TEXT,
    pmid BIGINT,
    pmcid BIGINT,
    journal TEXT,
    full_text_url TEXT,
    pub_date TEXT,
    authors TEXT[]
)
LANGUAGE plpgsql
AS $$
BEGIN
    RETURN QUERY
    SELECT
        e.id,
        e.content,
        1 - (e.embedding <=> query_embedding) AS similarity,
        r.id AS resource_id,
        r.title AS resource_title,
        r.pmid,
        r.pmcid,
        r.journal,
        r.full_text_url,
        r.pub_date,
        r.authors
    FROM embeddings e
    JOIN resources r ON e.resource_id = r.id
    WHERE 1 - (e.embedding <=> query_embedding) > match_threshold
    AND e.resource_id = ANY(resource_ids)
    ORDER BY e.embedding <=> query_embedding
    LIMIT match_count;
END;
$$;


CREATE OR REPLACE FUNCTION increment_processed_articles(task_id_param uuid)
RETURNS TABLE (new_processed_articles integer, is_complete boolean) AS $$
DECLARE
  new_count integer;
  total_count integer;
BEGIN
  -- Update processed_articles atomically and get the new value
  UPDATE tasks
  SET processed_articles = processed_articles + 1
  WHERE task_id = task_id_param
  RETURNING processed_articles INTO new_count;

  -- Get total_articles
  SELECT total_articles INTO total_count
  FROM tasks
  WHERE task_id = task_id_param;

  -- Return the new count and whether the task is complete
  RETURN QUERY
  SELECT new_count, (new_count >= total_count) AS is_complete;
END;
$$ LANGUAGE plpgsql;